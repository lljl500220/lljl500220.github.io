---
title: 2026面经
article: false
icon: note
---

一些面试遇到的问题，无关公司。
<!-- more -->

## http状态码

### 100 系列

不常见，主要用于某些高级协议。

100 Continue：客户端应继续发送请求的剩余部分。用于大文件上传前的确认。

101 Switching Protocols：服务器应客户端请求切换协议（如从 HTTP 切换到 WebSocket）。

### 200 系列 成功状态码

表示请求成功处理。

200 OK：最常见的成功状态。请求成功，响应体包含所请求的数据（如 HTML 页面、JSON 数据等）。

201 Created：请求成功并创建了新资源（如通过 POST 创建了新用户）。通常在响应中包含新资源的地址（Location头）。

204 No Content：请求成功，但响应体没有内容（常用于 DELETE 请求或不需返回数据的更新操作）。

206 Partial Content：服务器成功处理了部分 GET 请求（用于大文件的分块下载或断点续传）。

### 300 系列 重定向状态码

需要客户端重定向到另一个 URI 来完成请求。

301 Moved Permanently：永久重定向。请求的资源已永久移动到新的 URL。浏览器/客户端会缓存此重定向，后续请求会直接访问新地址。

302 Found：临时重定向。请求的资源临时从不同的 URL 响应。浏览器下次可能仍访问原地址。注意：历史上常被误用，HTTP/1.1 引入了 303 和 307 来明确语义。

304 Not Modified：与缓存相关。客户端发送附带条件（如 If-Modified-Since）的请求，资源未修改，服务器告诉客户端可以直接使用缓存版本。这不是重定向，而是节省带宽。

307 Temporary Redirect 和 308 Permanent Redirect： 分别是 302 和 301 的“严格”版本。它们要求重定向时不能改变原请求方法（例如 POST 必须仍为 POST）。

### 400 客户端错误状态码

意思就是错误发生在了客户端，比如401没带认证，404不存在资源，403不允许当前访问，比如权限不足等

400 Bad Request：通用错误。服务器因请求的语法、格式或无效信息而无法理解。

401 Unauthorized：未认证。请求需要用户身份验证。客户端应提供有效的认证凭据（如用户名/密码、Token）。

403 Forbidden：禁止访问。服务器理解请求但拒绝授权。与 401 不同，即使提供了身份验证也没用（权限不足）。

404 Not Found：最著名的错误码。服务器找不到请求的资源。可能是 URL 错误，或资源已被删除。

405 Method Not Allowed：请求行中指定的方法（GET, POST等）不允许用于该资源（例如，对只读资源使用 POST）。

408 Request Timeout：服务器等待请求超时。

409 Conflict：请求与服务器当前状态冲突（例如，更新资源时版本冲突）。

429 Too Many Requests：客户端在给定时间内发送了太多请求（速率限制）。

### 500 服务器错误

问题出在服务器处理请求时。

500 Internal Server Error：通用服务器错误。服务器遇到意外情况，无法完成请求。可能是后端代码抛出了未捕获的异常。

501 Not Implemented：服务器不支持完成请求所需的功能（例如，客户端使用了服务器不认识的 HTTP 方法）。

502 Bad Gateway：作为网关或代理的服务器，从上游服务器收到了无效响应。

503 Service Unavailable：服务器暂时不可用（通常由于过载或维护）。这是临时状态，响应中应包含 Retry-After头提示客户端何时重试。

504 Gateway Timeout：作为网关或代理的服务器，未能及时从上游服务器收到响应。


## 盒模型

首先说一下盒子，盒子就是任何一个元素，都会被当作一个矩形区域，形成一个`盒子`。盒子包括content，padding，border，margin四个部分组成。

盒子有两种，通过box-sizing属性切换  

第一种是web标准的content-box，所谓的标准盒模型。顾名思义，这是一个以内容为box的盒子，计算高宽时，直接使用width、height属性
得到的是content的值，而非盒子实际占位的数值，非常不直观。  

另一种则是border-box，怪异盒模型（哼，谁怪还用多说？），它的计算公式非常直观：宽高等于content，padding，border，margin相加，
符合人眼直觉。所以一般来说，对于统一的b端项目，都会在全局样式设置元素的box-sizing为border-box

## flex:1
有点尬住，忘了basis这个玩意怎么拼来着，也不会读，之说还有个属性是控制基础尺寸为0

flex: 1是 flex: 1 1 0的简写，具体拆解为：

flex-grow: 1  - 可以扩展，占满剩余空间

flex-shrink: 1  - 可以收缩，防止溢出

flex-basis: 0  - 基础尺寸为 0

## 数据结构与算法
### 排序
我必须狠狠地刷算法，打死每一个要问前端算法的面试官

#### 冒泡
讲讲思想：一个n^2的遍历，每次都执行一个 前后对比 将当前最大的数移动到数组最后，移动最多n-1次自然得到了一个从小到大的数组。

特性：*稳定*，*n²*
```javascript
function popSort(arr) {
    const n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        let isSorted = false;
        for (let j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j+1], arr[j]];
                isSorted = true;
            }
        }
        if (!isSorted) {
            break;
        }
    }
    return arr;
}
```
举一反三一下，怎么搞倒序排序呢？很简单，只需要改成小于不就行了对吧！
```javascript
function popSort(arr) {
    const n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        let isSorted = false;
        for (let j = 0; j < n - 1 - i; j++) {
            if (arr[j] < arr[j + 1]) { // 改这个条件
                [arr[j], arr[j + 1]] = [arr[j+1], arr[j]];
                isSorted = true;
            }
        }
        if (!isSorted) {
            break;
        }
    }
    return arr;
}
```

#### 选择排序
每次循环都从剩余未排序的内容选出一个最小的放到未排序中的第一位，其实说白了和冒泡是反过来的，一个把最大的往后抛，一个把最小的往前拿
```javascript
function choseSort(arr) {
    const n = arr.length;
    let minIndex = 0
    while (minIndex < n - 1){
        let findMin = minIndex;
        for (let i = minIndex + 1; i < n; i++) {
            if (arr[i] < arr[findMin]) {
                findMin = i
            }
        }
        [arr[findMin],arr[minIndex]] = [arr[minIndex],arr[findMin]];
        minIndex++;
    }
    return arr;
}

```

