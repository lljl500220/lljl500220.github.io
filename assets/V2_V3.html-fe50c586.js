import{_ as e,V as t,W as p,X as o,Y as n,Z as s,a0 as c,a2 as i,F as l}from"./framework-82b537ca.js";const u="/carefree/reactive.png",r="/carefree/createReactiveObject.png",k={},d=n("p",null,"基于前端技术趋同这个趋势，谈谈为什么我们要使用vue3，以及vue2和vue3的优缺点。",-1),v=n("h2",{id:"开篇",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#开篇","aria-hidden":"true"},"#"),s(" 开篇")],-1),m={href:"https://medium.com/js-dojo/vue-3-was-a-mistake-that-we-should-not-repeat-81cc65484954",target:"_blank",rel:"noopener noreferrer"},b=n("ol",null,[n("li",null,[s("vue3移除了event api，也就是"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"o"),n("mi",null,"n"),n("mo",{separator:"true"},",")]),n("annotation",{encoding:"application/x-tex"},"on,")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mpunct"},",")])])]),s("off,$once等等,致使从前使用了event bus的项目需要重写这种以vue实例作为事件总线通信工具的结构。")]),n("li",null,"在一些大型项目的编译程序上，转v3后会遇到相当体量的breaking change，编译过程中修复报错比较困难。"),n("li",null,"原来的选项式api向现在的组合式api的转变，让该文作者认为，vue3没有坚持vue自己的风格，转变向了react的类似风格。"),n("li",null,"以及其它的一些生态系统和使用反馈的问题，这里就不一一赘述了。")],-1),f=i(`<p>尤大大针对以上问题的回复是这样的:</p><ol><li>vue会为所有的版本提供相同的api核心，以达到完全兼容的目的，目前阻碍用户进行升级的内容实际上是第三方的框架，如nuxt等。<div class="hint-container info"><p class="hint-container-title">tip</p><p>事实上，几乎所有的api都能在更版本的vue迭代中找到替代方案，如event bus需求，可以使用mitt等方法实现。</p></div></li><li>实际使用过 Composition API + &lt; script setup&gt; 的用户在真是开发中的反馈非常积极，证明这是一个有价值的补充， 现在他们中的许多人更喜欢它而不是 Options API。</li><li>我们当然可以更好地处理新 API 的引入，但仅仅因为存在争议，并不意味着它是错误的或者不必要的。实际上，引入大的、新的想法的行为，势必会让那些喜欢呆在舒适区的人感到不安，但如果我们迎合这种心态，就永远不会取得真正的进展。</li></ol><p>自从vue3发布大版本3.2之后，逐渐趋于稳定。社区环境中关于vue的内容也逐渐转向vue3而非vue2，同样的，vue研发团队也不再为vue2进行重大功能的开发和更新。这就使得 vue生态发生了改变。</p><p>曾经我也是认为vue2的选项式api有着vue自己的特色，但是在使用了setup语法糖之后，☀️嗯真香~。新的组合式api让其它语言的开发者明显降低了进入vue的精力，也让vue开发者更容易接触到其它框架的内容。</p><p>接下来说一说vue2和vue3的优缺点</p><h2 id="vue2vue3" tabindex="-1"><a class="header-anchor" href="#vue2vue3" aria-hidden="true">#</a> vue2👊vue3</h2><h3 id="vue2" tabindex="-1"><a class="header-anchor" href="#vue2" aria-hidden="true">#</a> vue2</h3><p>vue2是一个非常成功也非常值得肯定的框架，一度在git上超越同等架构如react数万个star。应用场景相当广泛，学习成本之低远远超越任何一种js框架，使得vue在众多前端框架中脱颖而出。</p><p>我认为vue在2.x版本后能够如此迅速增长用户的原因有三点：</p><ol><li>创新性的响应式数据。</li><li>组合式api。</li><li>SFC的文件写法，摒弃了传统的文件分家思想。</li></ol><p>以及vue传统的router和vuex。</p><p>vue2的缺点也不少：</p><ol><li>相信很多开发者在使用vue2进行开发的时候都遇到了数据更行但是dom无法更新的情况。</li><li>当同一个组件中逻辑过多时，选项式api往往会将同一种逻辑分装在data，method，以及其它的watch等模块中，造成维护困难。</li><li>渲染消耗资源其实是相对大的，比起原生的js来说，往往会消耗更多的资源去处理dom。</li></ol><h3 id="vue3" tabindex="-1"><a class="header-anchor" href="#vue3" aria-hidden="true">#</a> vue3</h3><p>快！自由！这是我对vue3的第一认知。<br> 为什么快？vue3做了一系列的重新设计：</p><ol><li>首当其冲的就是diff算法的优化<a href="">diff算法解读</a></li><li>直接改变了响应式数据的劫持方式<div class="hint-container tip"><p class="hint-container-title">提示</p><p>vue2通过Object.defineProperty(obj, prop, descriptor)的方法去劫持数据，在数据对象上直接定义了一个新的属性或者修改对象属性，等于是重新包装了一次对象，对访问和写入做了拦截。 这样会造成的问题就是：</p><ol><li>递归遍历数据对象属性，消耗大</li><li>新增/删除属性，数据无响应；需要额外方法实现(Vue.set/Vue.delete、this.set/get/$delete)</li><li>数组修改需要额外方法实现(Vue.set)，或者通过重写的push/pop/shift/unshift/splice/sort/reverse方法实现</li></ol><p>vue3则通过Proxy（代理）方式，代理了对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。 然后通过通过Reflect（反射）机制，对数据对象的源头进行操作。<br> 一个响应式的实现实例</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> target <span class="token operator">!==</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> target <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> target
<span class="token punctuation">}</span>
<span class="token comment">// 代理配置</span>
<span class="token keyword">const</span> proxyConf <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//只监听对象本身（非原型）属性</span>
      <span class="token keyword">const</span> ownKeys <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>ownKeys<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//如果是本身的属性就监听，如果是对象原型的属性就不监听</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>   
      <span class="token comment">//(惰性)深度监听--&gt;提升性能   </span>
      <span class="token keyword">return</span> <span class="token function">reactive</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>  
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 重复的数据不处理   </span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>   
      <span class="token punctuation">}</span>
      <span class="token comment">// 监听是否是新增的key</span>

      <span class="token keyword">const</span> ownKeys <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>  
      <span class="token keyword">if</span> <span class="token punctuation">(</span>ownKeys<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;已有的key&quot;</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;新增的key&quot;</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;set&quot;</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
      <span class="token keyword">return</span> result <span class="token comment">//通过return的值可以看出是否设置成功</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">deleteProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;delete property&quot;</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
      <span class="token keyword">return</span> result <span class="token comment">//是否删除成功</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>  
<span class="token punctuation">}</span>

<span class="token comment">// 生成代理对象 </span>
<span class="token keyword">const</span> observed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> proxyConf<span class="token punctuation">)</span>
  <span class="token keyword">return</span> observed

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>顺便看一下vue3中的响应式实现源码：<br><img src="`+u+'" alt="reactive" loading="lazy"></p><p>可以看到，reactive方法return了createReactiveObject函数，所以去看createReactiveObject。</p><figure><img src="'+r+'" alt="createReactiveObject" tabindex="0" loading="lazy"><figcaption>createReactiveObject</figcaption></figure></div></li><li>按需编译，动态引入。</li><li>新增的片段等特性。 诸如以上的内容等等。</li></ol>',16);function h(y,g){const a=l("ExternalLinkIcon");return t(),p("div",null,[d,o(" more "),v,n("p",null,[s("V3刚刚发布的时候，vue社区曾经出现过一篇文章，文意直指从vue2升级至vue3是一个极度错误的决定。 "),n("a",m,[s("原文链接"),c(a)]),s("， 彼时尤大还亲自下场和该文作者论证过一些问题。 文章指出以下几点问题:")]),b,f])}const _=e(k,[["render",h],["__file","V2_V3.html.vue"]]);export{_ as default};
