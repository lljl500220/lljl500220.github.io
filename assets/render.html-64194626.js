import{_ as i,V as o,W as t,X as n,Y as e,Z as a,a0 as d,a2 as r,F as c}from"./framework-82b537ca.js";const l="/learn/渲染流程.png",h="/learn/domTree.png",p="/learn/cssomTree.png",m="/learn/浏览器计算属性.png",g="/learn/分层结构.png",u={},f=e("p",null,"有关浏览器渲染机制的学习",-1),_=r('<h2 id="浏览器渲染原理" tabindex="-1"><a class="header-anchor" href="#浏览器渲染原理" aria-hidden="true">#</a> 浏览器渲染原理</h2><p>先看看这个图：</p><figure><img src="'+l+'" alt="渲染原理" tabindex="0" loading="lazy"><figcaption>渲染原理</figcaption></figure><p>接下来我们从每一个节点来分析浏览器在做什么。</p><h3 id="输入url-解析url" tabindex="-1"><a class="header-anchor" href="#输入url-解析url" aria-hidden="true">#</a> 输入url，解析url</h3><p>没啥可说的，浏览器接收一个url，从该url获取到html文本，这个过程涉及到更多的http通信知识，这篇我们学习浏览器渲染就不说了，当然，俺现在也说不清楚。</p><h3 id="解析html" tabindex="-1"><a class="header-anchor" href="#解析html" aria-hidden="true">#</a> 解析html</h3><p>从这段开始，就是我们要说的主要内容了。 渲染的第一步就是解析html，在解析htm的过程开始之前，浏览器会开辟出一个与构建线程，该线程用于提前下载html中链接的css和js文件。<br> 在解析过程中，遇到css就执行css，遇到js就执行js。但是！如果遇到css时css并没有下载完成，则会跳过该css，继续解析之后的内容。但是遇到js时，如果js没有下载好，就会暂停当前的解析， 转而等待js下载完成。这是因为js代码有可能会修改到dom或者cssom，必须等待js执行。</p><h3 id="构建dom树" tabindex="-1"><a class="header-anchor" href="#构建dom树" aria-hidden="true">#</a> 构建dom树</h3><p>在解析html的过程中，主线程会读取到html中的各种节点，包括html，head，body，div，p，a...这些内容将被构建为一个树形结构，根节点就是document，每个子节点就是一个 <em><strong>c++对象</strong></em>。形如下图：</p><figure><img src="'+h+'" alt="dom树结构" tabindex="0" loading="lazy"><figcaption>dom树结构</figcaption></figure><h3 id="构建cssom树" tabindex="-1"><a class="header-anchor" href="#构建cssom树" aria-hidden="true">#</a> 构建cssom树</h3><p>在解析html的过程中，当预构建线程下载完毕css文件后，或者本就没有外部的css文件，主线程会读取css内容，生成一个与dom树相同结构的cssom树，每个子节点同样是一个c++对象。</p><figure><img src="'+p+'" alt="cssom树结构" tabindex="0" loading="lazy"><figcaption>cssom树结构</figcaption></figure><p>浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p><h3 id="计算样式、获取布局" tabindex="-1"><a class="header-anchor" href="#计算样式、获取布局" aria-hidden="true">#</a> 计算样式、获取布局</h3><p>在获取到cssom和dom后，主线程将两者合并，启动样式计算<br> 在浏览器的控制台中，如果有关注过style的话，会发现style存在一列名为&quot;已计算&quot;或&quot;computed&quot;</p><figure><img src="'+m+'" alt="计算属性" tabindex="0" loading="lazy"><figcaption>计算属性</figcaption></figure><p>在这个位置，会发现每个元素都有着所有理论存在的css属性，这些属性是开发者并没有书写的内容，比如我们写了一个div，设置其color:red。 但是在计算属性中，所以div会存在的css属性都会经过浏览器的计算(通过dom和cssom)获得一个默认值。</p>',19),b={class:"hint-container info"},x=e("p",{class:"hint-container-title"},"盒模型的理解",-1),y={href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block",target:"_blank",rel:"noopener noreferrer"},j=r('<p>dom树和布局树并不是同种事物，通常，在dom树中会解析出display:none的节点，但是在布局树中并不会出现该节点。在dom树中并不会解析出伪元素节点，但是在布局树中，伪元素也被认为是节点之一，因为需要布局。 此外，还有一些行盒，块盒等都不会在dom中体现，反而在布局中却需要体现。</p><p>通常来说，布局树意味着已经生成了每个节点的几何信息。</p><h3 id="分层渲染" tabindex="-1"><a class="header-anchor" href="#分层渲染" aria-hidden="true">#</a> 分层渲染</h3><p>在布局计算完毕，获取到布局树之后，浏览器会使用一系列复杂的策略，对获取到的布局树进行分层。<br> 分层是为了在节点被修改后更快的重新渲染，而非整体页面再渲染一次。在google浏览器中，可以通过控制台的3d视图清晰的看到当前页面的分层情况，比如：</p><figure><img src="'+g+'" alt="分层" tabindex="0" loading="lazy"><figcaption>分层</figcaption></figure><p>浏览器会有自己的策略决定该页面是否需要分层，需要分多少层。但是有一些css属性能够<em><strong>影响</strong></em>到分层策略(请注意，我使用的是影响而不是决定)。比如熟知的z-index以及will-change属性。</p><h3 id="绘制图形" tabindex="-1"><a class="header-anchor" href="#绘制图形" aria-hidden="true">#</a> 绘制图形</h3><p>绘制图形并不代表着整个流程已经完成了，它仅仅是主线程对每个分层生成了一个绘制策略-可以认为是形成了一个对计算机的指令几何，告诉接下来的工作需要如何执行。</p><ol><li>主线程对每个分层都形成一个独立的绘制指令集，用于描述该分层需要如何绘制。</li><li>将这些指令集分发给合成线程，接下来的工作将从主线程转移到合成线程。</li><li>合成线程对每个图层进行分块，可能是像素基点，也可能是屏幕的一部分，取决于浏览器策略。</li><li>分块活动是一个数量非常多的任务集合，所以合成线程将会从线程池取出一些线程进行分块工作。</li></ol><h3 id="光栅化" tabindex="-1"><a class="header-anchor" href="#光栅化" aria-hidden="true">#</a> 光栅化</h3><p>光栅化是将html的描述性信息转化为像素信息的过程，事实上，不止是浏览器，任何有关图像输出的地方都存在光栅化。<br> 在浏览器中，绘制线程通过分块后，获得了每个块区的每个像素点的色彩值，这个矩阵形式的色彩值集合将发送给光栅线程，该线程通过一些与gpu交互的手段，比如gpu加速等获得图像信息(像素数据)。<br> 这个像素数据事实上仍然不是我们所看到的图像信息，它是一块块的位图（确定了每个像素点的绝对位置和色彩信息）</p><h3 id="画" tabindex="-1"><a class="header-anchor" href="#画" aria-hidden="true">#</a> 画</h3><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。<br> 指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。<br> 变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质原因。<br> 合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p>',13);function v(z,k){const s=c("ExternalLinkIcon");return o(),t("div",null,[f,n(" more "),_,e("div",b,[x,e("p",null,[a("在之前的一些知识内容中，我们通常会错误的认为，一个盒子包含了一些元素，那么这个盒子就是子元素的包含块。事实上并不是的，"),e("a",y,[a("在最新的w3c标准中"),d(s)]),a("， 对包含块有了一些新的解释。感兴趣的可以前往看看。 包含块决定了生成布局树时的元素定位！")])]),j])}const C=i(u,[["render",v],["__file","render.html.vue"]]);export{C as default};
