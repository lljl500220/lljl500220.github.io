import{a0 as a,O as t,P as r,U as h,Q as e,X as d}from"./framework-d6e74f8b.js";const s={},o=e("p",null,"书接上回，上回我们讲到-赛博坦上起狼烟，黛玉七擒威震天！",-1),n=e("p",null,"话说这赛博坦世界，本非金雕玉砌只邦，原是铁骨钢胎所在。那乾坤之间，不见日月轮转，唯有能量潮汐起落，紫霞青焰交织成昼夜....",-1),c=e("p",null,"偏题了不好意思，脱口相声下次再说，下面我们一起来看看vite的热更新，插件的内容",-1),i=d('<h2 id="hmr" tabindex="-1"><a class="header-anchor" href="#hmr" aria-hidden="true">#</a> HMR</h2><p>曾经我面试过一个候选人，我问HMR是什么，他说不知道。我又问热更新是什么，他说是热更新...</p><p>emmm，以上为真实场景，没有半点虚构，HMR，全名叫做Hot Module Replacement，顾名思义，热模块替换，也叫做热更新。</p><p>它有什么作用呢？ 写了代码，按下保存按键之后，不需要刷新页面就能看到改变，乃至于滚动条，表单状态都不会改变和丢失，现代前端框架几乎都已经实现了hmr的开发阶段功能。</p><h3 id="核心原理" tabindex="-1"><a class="header-anchor" href="#核心原理" aria-hidden="true">#</a> 核心原理</h3><h4 id="websocket链接" tabindex="-1"><a class="header-anchor" href="#websocket链接" aria-hidden="true">#</a> Websocket链接</h4><p>众所周知，启动vite时，会启动一个服务器，浏览器上预览我们的页面时，实际上是请求了这个服务，他们之间会建立一个长链接的关系。vite监听到文件的变化后，会推送一个消息给 浏览器，浏览器就知道这个位置改变了，重新渲染一下。</p><h4 id="模块依赖图" tabindex="-1"><a class="header-anchor" href="#模块依赖图" aria-hidden="true">#</a> 模块依赖图</h4><p>上文说过，vite会维护一张模块之间的依赖图谱(Module Graph)，用于记录模块之间的引用关系，当某个模块变化后，顺着依赖图一直找，找到所有受影响的部分，就能实现精准的定位。</p><h4 id="为什么修改ts文件会发生整页刷新的情况" tabindex="-1"><a class="header-anchor" href="#为什么修改ts文件会发生整页刷新的情况" aria-hidden="true">#</a> 为什么修改ts文件会发生整页刷新的情况</h4>',10);function l(p,_){return t(),r("div",null,[o,n,c,h(" more "),i])}const u=a(s,[["render",l],["__file","part_two.html.vue"]]);export{u as default};
