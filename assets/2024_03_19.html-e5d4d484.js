const t=JSON.parse('{"key":"v-7b99c55a","path":"/posts/learn/algorithm/LeetCode/2024_03_19.html","title":"2024-03-19","lang":"zh-CN","frontmatter":{"title":"2024-03-19","icon":"code","article":false,"isOriginal":true,"category":["算法"],"tag":["typeScript","algorithm"],"description":"1793. 好子数组的最大分数 （困难） 给你一个整数数组 nums （下标从 0 开始）和一个整数 k 。 一个子数组 (i, j) 的 分数 定义为 min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1) 。一个 好 子数组的两个端点下标需要满足 i &lt;= k &lt;= j 。 请你返回 好 子数组的最大可能 分数 。 示例1： 输入：nums = [1,4,3,7,4,5], k = 3 输出：15 解释：最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。","head":[["meta",{"property":"og:url","content":"https://lljl500220.github.io/posts/learn/algorithm/LeetCode/2024_03_19.html"}],["meta",{"property":"og:site_name","content":"秦篆"}],["meta",{"property":"og:title","content":"2024-03-19"}],["meta",{"property":"og:description","content":"1793. 好子数组的最大分数 （困难） 给你一个整数数组 nums （下标从 0 开始）和一个整数 k 。 一个子数组 (i, j) 的 分数 定义为 min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1) 。一个 好 子数组的两个端点下标需要满足 i &lt;= k &lt;= j 。 请你返回 好 子数组的最大可能 分数 。 示例1： 输入：nums = [1,4,3,7,4,5], k = 3 输出：15 解释：最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。"}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-01T08:26:56.000Z"}],["meta",{"property":"article:tag","content":"typeScript"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:modified_time","content":"2024-04-01T08:26:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"2024-03-19\\",\\"description\\":\\"1793. 好子数组的最大分数 （困难） 给你一个整数数组 nums （下标从 0 开始）和一个整数 k 。 一个子数组 (i, j) 的 分数 定义为 min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1) 。一个 好 子数组的两个端点下标需要满足 i &lt;= k &lt;= j 。 请你返回 好 子数组的最大可能 分数 。 示例1： 输入：nums = [1,4,3,7,4,5], k = 3 输出：15 解释：最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。\\"}"]]},"headers":[{"level":2,"title":"1793. 好子数组的最大分数 （困难）","slug":"_1793-好子数组的最大分数-困难","link":"#_1793-好子数组的最大分数-困难","children":[]},{"level":2,"title":"分析","slug":"分析","link":"#分析","children":[]},{"level":2,"title":"解题","slug":"解题","link":"#解题","children":[]},{"level":2,"title":"性能分析","slug":"性能分析","link":"#性能分析","children":[]},{"level":2,"title":"优化","slug":"优化","link":"#优化","children":[]}],"git":{"createdTime":1711960016000,"updatedTime":1711960016000,"contributors":[{"name":"luolj","email":"luolj@si-tech.com.cn","commits":1}]},"readingTime":{"minutes":3.21,"words":962},"filePathRelative":"posts/learn/algorithm/LeetCode/2024_03_19.md","localizedDate":"2024年4月1日","excerpt":"<h2> 1793. 好子数组的最大分数 （困难）</h2>\\n<p>给你一个整数数组 nums （下标从 0 开始）和一个整数 k 。</p>\\n<p>一个子数组 (i, j) 的 分数 定义为 min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1) 。一个 好 子数组的两个端点下标需要满足 i &lt;= k &lt;= j 。</p>\\n<p>请你返回 好 子数组的最大可能 分数 。</p>\\n<blockquote>\\n<p>示例1：<br>\\n输入：nums = [1,4,3,7,4,5], k = 3<br>\\n输出：15<br>\\n解释：最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。</p>\\n</blockquote>","autoDesc":true}');export{t as data};
